// Copyright (c) 2017 University of Minnesota
// 
// MCLSCENE Uses the BSD 2-Clause License (http://www.opensource.org/licenses/BSD-2-Clause)
// Redistribution and use in source and binary forms, with or without modification, are
// permitted provided that the following conditions are met:
// 1. Redistributions of source code must retain the above copyright notice, this list of
//    conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright notice, this list
//    of conditions and the following disclaimer in the documentation and/or other materials
//    provided with the distribution.
// THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE UNIVERSITY OF MINNESOTA, DULUTH OR CONTRIBUTORS BE 
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
// OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
// IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// By Matt Overby (http://www.mattoverby.net)

#ifndef MCLSCENE_VEC3_H
#define MCLSCENE_VEC3_H 1

#include <Eigen/Geometry> // needed for cross product
#include "Vec.h" // trimesh's vec
#include "XForm.h" // trimesh transforms
#include <vector>

//
//	You can replace the internal vector type
//	by changing these typedefs.
//
namespace mcl {

	template <typename T> using Vec4 = Eigen::Matrix<T,4,1>;
	template <typename T> using Vec3 = Eigen::Matrix<T,3,1>;
	template <typename T> using Vec2 = Eigen::Matrix<T,2,1>;

	// Common vecs that I don't feel like typing out all the time:
	typedef Vec4<float> Vec4f;
	typedef Vec3<float> Vec3f;
	typedef Vec2<float> Vec2f;
	typedef Vec4<double> Vec4d;
	typedef Vec3<double> Vec3d;
	typedef Vec2<double> Vec2d;
	typedef Vec4<int> Vec4i;
	typedef Vec3<int> Vec3i;
	typedef Vec2<int> Vec2i;

	// Temporary quick fix for interop. Will remove once I wean off trimesh.
	static inline Vec3f to_Vec3f(trimesh::vec p){ return Vec3f(p[0],p[1],p[2]); }

	// Just for formatting output
	template <typename T> static inline std::string to_str(const Vec3<T> &v){
		std::stringstream ss; ss << v[0] << ' ' << v[1] << ' ' << v[2];
		return ss.str();
	}

	struct VertexPool {
		VertexPool() : valid(false) {}
		bool valid;
		//
		// Vertex pools can be generated by SceneManager::get_vertex_pool.
		// They are helpful for doing updates in the Simulator class.
		//
		// If your meshes don't change size, you can generate this
		// struct once and keep reusing it.
		//
		// Each element in the vectors below is for a different object.
		// For example, if you wanted the 14th vertex of the 3rd object,
		// it would be:
		//	Vec3f v( pool.vertices[3][14*3+0], pool.vertices[3][14*3+1], pool.vertices[3][14*3+2] );
		//
		// If you called get_vertex_pool with "dynamic only" on, you'll need to use
		// the index vector (below) to find the 3rd object, instead of using
		// the code above. For example:
		// 	for( int i=0; i<pool.index.size(); ++i ){
		//		if( pool.index[i]==3 ){
		//			Vec3f v( pool.vertices[i][14*3+0], ...
		//
		std::vector<int> num_vertices;
		std::vector<float*> vertices;

		std::vector<int> num_normals;
		std::vector<float*> normals;

		std::vector<int> num_texcoords;
		std::vector<float*> texcoords;

		std::vector<int> num_faces;
		std::vector<int*> faces;

		std::vector<int> index; // index into SceneManager::objects

		void clear(){
			num_vertices.clear(); vertices.clear();
			num_normals.clear(); normals.clear();
			num_texcoords.clear(); texcoords.clear();
			num_faces.clear(); faces.clear();
			index.clear();
		}

	}; // end vertex pool


	// Eventually I will put enums in a better place
	// Material settings:
	enum {
		// Can be returned as object's material:
		MATERIAL_INVISIBLE = -2,
		MATERIAL_NOTSET = -1,

		// Material flags:
		MATERIAL_RED_BACKFACE = 1 << 0, // Color backfacing triangles red
//		SECOND = 1 << 1, // future
	};


	// Assumes T is float or double
	template <typename T> static inline Vec3<T> spherical_to_cartesian(T theta, T phi){
		T sin_t, cos_t, sin_p, cos_p;
		sincosf(theta, &sin_t, &cos_t);
		sincosf(phi, &sin_p, &cos_p);
		return Vec3<T>( sin_t * sin_p, sin_t * cos_p, cos_t );
	}

	template <typename T> static inline Vec2<T> cartesian_to_spherical(const Vec3<T> &v){
		Vec2<T> r( std::acos(v[2]), std::atan2(v[1], v[0]) );
		if(r[1] < 0){ r[1] += 2*M_PI; }
		return r;
	}

} // end namespace mcl


//
//	trimesh and mcl::Vec xforms:
//
namespace trimesh {

	template <typename T, typename U> static inline mcl::Vec3<T> operator*(const trimesh::XForm<U> &m, const mcl::Vec3<T> &v){
		mcl::Vec3<T> r;
		r[0] = m[0]*v[0]+m[4]*v[1]+m[8]*v[2]+m[12];
		r[1] = m[1]*v[0]+m[5]*v[1]+m[9]*v[2]+m[13];
		r[2] = m[2]*v[0]+m[6]*v[1]+m[10]*v[2]+m[14];
		return r;
	}

	template <typename T, typename U> static inline mcl::Vec4<T> operator*(const trimesh::XForm<U> &m, const mcl::Vec4<T> &v){
		mcl::Vec4<T> r;
		r[0] = m[0]*v[0]+m[4]*v[1]+m[8]*v[2]+m[12]*v[3];
		r[1] = m[1]*v[0]+m[5]*v[1]+m[9]*v[2]+m[13]*v[3];
		r[2] = m[2]*v[0]+m[6]*v[1]+m[10]*v[2]+m[14]*v[3];
		r[3] = m[3]*v[0]+m[7]*v[1]+m[11]*v[2]+m[15]*v[3];
		return r;
	}

} // end namespace trimesh

#endif
